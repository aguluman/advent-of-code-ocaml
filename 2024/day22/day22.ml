(** {1 Day 22: Monkey Market - Secret Number Trading Challenge}

    This module solves Advent of Code Day 22 challenge about predicting buyer
    behavior in a monkey market. The module analyzes pseudorandom sequences of
    secret numbers and price patterns to maximize banana trades.

    {2 Problem Details}

    - {b Input:} Initial secret numbers for each buyer in the Monkey Exchange
      Market
    - {b Part 1:} Calculate sum of 2000th secret number generated by each
      buyer's algorithm
    - {b Part 2:} Find optimal price pattern to maximize banana trades across
      all buyers

    {2 Secret Number Evolution Process}
    Each secret number evolves through a three-step process:

    - Multiply by 64, mix (XOR), and prune (modulo 16777216)
    - Divide by 32, mix (XOR), and prune (modulo 16777216)
    - Multiply by 2048, mix (XOR), and prune (modulo 16777216)

    {b Implementation Note:} The solution uses parallel processing and efficient
    data structures for performance optimization.

    @see <https://adventofcode.com/2024/day/22> Advent of Code 2024, Day 22 *)

open Domainslib

(** Mixes two values using XOR operation

    - The mixing operation combines a value with a secret number using bitwise
      XOR (^^^).
    - This is part of the secret number evolution process in the Monkey Market
      simulation.

    @param value The value to mix into the secret number
    @param secret The current secret number
    @return The result of XORing value with secret *)
let mix value secret = Int64.logxor value secret

(** Prunes the secret number by taking modulo 16777216

    - This function keeps the secret number within bounds by applying modulo
      operation.
    - Part of the secret number evolution process in the Monkey Market
      simulation.

    @param secret The secret number to prune
    @return The result of secret modulo 16777216L *)
let prune secret = Int64.rem secret 16777216L

(** Generates the next secret number in the sequence using the monkey's
    algorithm

    Each secret number evolves through three transformations: 1. Multiply by 64,
    mix (XOR), and prune (modulo 16777216) 2. Divide by 32, mix (XOR), and prune
    (modulo 16777216) 3. Multiply by 2048, mix (XOR), and prune (modulo
    16777216)

    @param secret The current secret number to evolve
    @return
      The next secret number in the sequence after applying all transformations
*)
let next secret =
  let secret = secret |> mix (Int64.mul secret 64L) |> prune in
  let secret = secret |> mix (Int64.div secret 32L) |> prune in
  secret |> mix (Int64.mul secret 2048L) |> prune

(** Calculates sum of 2000th secret number for each buyer

    For each buyer's initial secret number, the function:
    + Generates 2000 new secret numbers using the monkey's algorithm
    + Takes the 2000th number in the sequence
    + Sums these numbers across all buyers

    The secret number evolution follows these steps:
    - Multiply by 64, mix, and prune
    - Divide by 32, mix, and prune
    - Multiply by 2048, mix, and prune

    @param initial_secrets Array of initial secret numbers for each buyer
    @return Sum of the 2000th secret number from each buyer's sequence *)
let part1 initial_secrets =
  Array.fold_left
    (fun sum initial ->
      let nth_secret = ref initial in
      for _ = 1 to 2000 do
        nth_secret := next !nth_secret
      done;
      Int64.add sum !nth_secret)
    0L initial_secrets

(** Finds the optimal price pattern in the Monkey Exchange Market to maximize
    banana trades

    Algorithm steps:
    + Generate price sequences (0-9) for each buyer's next 2000 secret numbers
    + Calculate price changes between consecutive numbers
    + Find patterns of 4 consecutive price changes
    + Track total banana prices for each unique pattern
    + Return the maximum possible banana price achievable

    Price patterns are tracked as 4-tuples of consecutive price changes. Each
    change represents the difference between consecutive prices. The function
    uses parallel processing for generating sequences and changes.

    @param initial_secrets Array of initial secret numbers from each buyer
    @return
      Maximum number of bananas obtainable using the optimal price change
      pattern *)
let part2 initial_secrets =
  (* Create optimal number of domains based on available cores *)
  let num_domains = max 1 (Domain.recommended_domain_count () - 1) in
  (* Use larger chunks for better cache locality and reduced overhead *)
  let chunk_size = max 32 (Array.length initial_secrets / num_domains) in
  let pool = Domainslib.Task.setup_pool ~num_domains () in

  (* Process buyer secrets in parallel with larger chunks for better performance *)
  let results_array =
    Array.make (Array.length initial_secrets) (Hashtbl.create 0)
  in
  Task.run pool (fun () ->
      Task.parallel_for pool ~chunk_size ~start:0
        ~finish:(Array.length initial_secrets - 1)
        ~body:(fun i ->
          let buyer_secret = initial_secrets.(i) in

          (* Use integer-keyed hashtables for better performance *)
          let local_pattern_map = Hashtbl.create 1024 in
          let seen_patterns = Hashtbl.create 1024 in

          (* Pre-allocate all arrays for the full sequence *)
          let current = ref buyer_secret in
          let prices = Array.make 5 0L in

          (* Generate initial prices (unrolled for better performance) *)
          prices.(0) <- Int64.rem !current 10L;
          current := next !current;
          prices.(1) <- Int64.rem !current 10L;
          current := next !current;
          prices.(2) <- Int64.rem !current 10L;
          current := next !current;
          prices.(3) <- Int64.rem !current 10L;
          current := next !current;
          prices.(4) <- Int64.rem !current 10L;
          current := next !current;

          (* Create a sliding window of 4 changes (5 prices) *)
          let changes = Array.make 4 0L in

          (* Calculate initial changes (unrolled) *)
          changes.(0) <- Int64.sub prices.(1) prices.(0);
          changes.(1) <- Int64.sub prices.(2) prices.(1);
          changes.(2) <- Int64.sub prices.(3) prices.(2);
          changes.(3) <- Int64.sub prices.(4) prices.(3);

          (* Initial pattern encoding - inline calculation to avoid function call *)
          let c1_int = Int64.to_int changes.(0) + 9 in
          let c2_int = Int64.to_int changes.(1) + 9 in
          let c3_int = Int64.to_int changes.(2) + 9 in
          let c4_int = Int64.to_int changes.(3) + 9 in
          let pattern_int =
            ref
              (c1_int + (c2_int * 19)
              + (c3_int * 19 * 19)
              + (c4_int * 19 * 19 * 19))
          in

          (* Process first pattern *)
          if not (Hashtbl.mem seen_patterns !pattern_int) then (
            Hashtbl.add seen_patterns !pattern_int ();
            Hashtbl.add local_pattern_map !pattern_int prices.(4));

          (* Process remaining sequences with larger batches *)
          let batch_size = 400 in
          (* Larger batches for better amortized overhead *)

          for batch_idx = 0 to (2000 - 5) / batch_size do
            let batch_start = 5 + (batch_idx * batch_size) in
            let batch_end = min 2000 (batch_start + batch_size - 1) in

            (* Pre-allocate batch prices array *)
            let batch_size_actual = batch_end - batch_start + 1 in
            let batch_prices = Array.make batch_size_actual 0L in
            let current_batch = ref !current in

            (* Generate batch prices with minimal allocations and unrolled where possible *)
            for i = 0 to batch_size_actual - 1 do
              batch_prices.(i) <- Int64.rem !current_batch 10L;
              current_batch := next !current_batch
            done;

            (* Update current for next batch *)
            current := !current_batch;

            (* Process batch with optimized loops *)
            for i = 0 to batch_size_actual - 1 do
              let price = batch_prices.(i) in

              (* Shift the window (optimized) - single assignment is faster than loop *)
              changes.(0) <- changes.(1);
              changes.(1) <- changes.(2);
              changes.(2) <- changes.(3);
              changes.(3) <- Int64.sub price prices.(4);

              (* Update prices (optimized) - single assignment is faster than loop *)
              prices.(0) <- prices.(1);
              prices.(1) <- prices.(2);
              prices.(2) <- prices.(3);
              prices.(3) <- prices.(4);
              prices.(4) <- price;

              (* Calculate pattern int directly - inlined for speed *)
              let c1_int = Int64.to_int changes.(0) + 9 in
              let c2_int = Int64.to_int changes.(1) + 9 in
              let c3_int = Int64.to_int changes.(2) + 9 in
              let c4_int = Int64.to_int changes.(3) + 9 in
              pattern_int :=
                c1_int + (c2_int * 19)
                + (c3_int * 19 * 19)
                + (c4_int * 19 * 19 * 19);

              (* Fast path for updating pattern map - no nested if statements *)
              if not (Hashtbl.mem seen_patterns !pattern_int) then (
                Hashtbl.add seen_patterns !pattern_int ();

                match Hashtbl.find_opt local_pattern_map !pattern_int with
                | Some existing ->
                    Hashtbl.replace local_pattern_map !pattern_int
                      (Int64.add existing price)
                | None -> Hashtbl.add local_pattern_map !pattern_int price)
            done
          done;

          results_array.(i) <- local_pattern_map;
          ()));

  let local_results = Array.to_list results_array in

  (* Pre-allocate final hashtable with size based on expected number of patterns *)
  let final_pattern_map = Hashtbl.create 8192 in

  (* Combine results with optimized iteration *)
  List.iter
    (fun local_map ->
      Hashtbl.iter
        (fun pattern_key value ->
          match Hashtbl.find_opt final_pattern_map pattern_key with
          | Some existing ->
              Hashtbl.replace final_pattern_map pattern_key
                (Int64.add existing value)
          | None -> Hashtbl.add final_pattern_map pattern_key value)
        local_map)
    local_results;

  (* Use immediate maximum computation instead of fold for better branch prediction *)
  let max_value = ref 0L in
  Hashtbl.iter
    (fun _ value ->
      if Int64.compare value !max_value > 0 then max_value := value)
    final_pattern_map;

  Domainslib.Task.teardown_pool pool;
  !max_value

(** Parses the input string into an array of initial secret numbers

    - Takes a string input with one number per line and converts each line to an
      Int64.
    - Empty lines and whitespace are handled appropriately.

    @param input Raw input string with one number per line
    @return Array of Int64 values representing initial secret numbers *)
let parse input =
  String.split_on_char '\n' input
  |> List.filter (fun s -> String.trim s <> "")
  |> List.map (fun line -> Int64.of_string (String.trim line))
  |> Array.of_list
